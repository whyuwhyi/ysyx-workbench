package common

import chisel3._
import chisel3.util._

case class CPUConfig(
  XLEN: Int = 32,
  coreType: CoreType.Type = CoreType.SingleCycle
) {
  val isRV64: Boolean = XLEN == 64
  val NR_REGS = if (extensions.contains('E')) 16 else 32
  val extensions: Seq[Char] = Seq('I', 'E')
}

trait HasCPUConfig {
  implicit val config: CPUConfig
}

trait ISA extends HasCPUConfig {
  object Opcodes {
    val LUI     = "b0110111".U
    val AUIPC   = "b0010111".U
    val JAL     = "b1101111".U
    val JALR    = "b1100111".U
    val BRANCH  = "b1100011".U
    val LOAD    = "b0000011".U
    val STORE   = "b0100011".U
    val OP_IMM  = "b0010011".U
    val OP      = "b0110011".U
    val SYSTEM  = "b1110011".U
  }

  object Funct3 {
    val ADD  = "b000".U; val SUB  = "b000".U
    val SLL  = "b001".U
    val SLT  = "b010".U
    val SLTU = "b011".U
    val XOR  = "b100".U
    val SRL  = "b101".U; val SRA  = "b101".U
    val OR   = "b110".U
    val AND  = "b111".U
    val ADDI = "b000".U
    val SLLI = "b001".U
    val SLTI = "b010".U
    val SLTIU= "b011".U
    val XORI = "b100".U
    val SRLI = "b101".U; val SRAI = "b101".U
    val ORI  = "b110".U
    val ANDI = "b111".U
    val BEQ  = "b000".U; val BNE  = "b001".U
    val BLT  = "b100".U; val BGE  = "b101".U
    val BLTU = "b110".U; val BGEU = "b111".U
    val LB   = "b000".U; val LH   = "b001".U; val LW   = "b010".U
    val LBU  = "b100".U; val LHU  = "b101".U
    val SB   = "b000".U; val SH   = "b001".U; val SW   = "b010".U
    val JALR = "b000".U
    val ECALL = "b000".U; val EBREAK = "b000".U; val MRET = "b000".U
    val CSRRW = "b001".U; val CSRRS = "b010".U; val CSRRC = "b011".U
    val CSRRWI= "b101".U; val CSRRSI= "b110".U; val CSRRCI= "b111".U
  }

  object Funct7 {
    val ADD  = "b0000000"; val SUB  = "b0100000"
    val SLL  = "b0000000"
    val SLT  = "b0000000"
    val SLTU = "b0000000"
    val XOR  = "b0000000"
    val SRL  = "b0000000"; val SRA  = "b0100000"
    val OR   = "b0000000"
    val AND  = "b0000000"
    val SLLI = "b0000000"
    val SRLI = "b0000000"; val SRAI = "b0100000"
  }
  
  object Funct12 {
      val ECALL = "b000000000000"
      val EBREAK = "b00000000001"
      val MRET = "b001100000010"
  }

  def LUI     = BitPat("b??????????????????????????" + Opcodes.LUI)
  def AUIPC   = BitPat("b??????????????????????????" + Opcodes.AUIPC)
  def JAL     = BitPat("b??????????????????????????" + Opcodes.JAL)
  def JALR    = BitPat("????????????" + Funct3.JALR + "?????" + Opcodes.JALR)
  def BEQ     = BitPat("???????" + "?????" + "?????" + Funct3.BEQ + "?????" + Opcodes.BRANCH)
  def BNE     = BitPat("???????" + "?????" + "?????" + Funct3.BNE + "?????" + Opcodes.BRANCH)
  def BLT     = BitPat("???????" + "?????" + "?????" + Funct3.BLT + "?????" + Opcodes.BRANCH)
  def BGE     = BitPat("???????" + "?????" + "?????" + Funct3.BGE + "?????" + Opcodes.BRANCH)
  def BLTU    = BitPat("???????" + "?????" + "?????" + Funct3.BLTU+ "?????" + Opcodes.BRANCH)
  def BGEU    = BitPat("???????" + "?????" + "?????" + Funct3.BGEU+ "?????" + Opcodes.BRANCH)
  def LB      = BitPat("????????????" + Funct3.LB  + "?????" + Opcodes.LOAD)
  def LH      = BitPat("????????????" + Funct3.LH  + "?????" + Opcodes.LOAD)
  def LW      = BitPat("????????????" + Funct3.LW  + "?????" + Opcodes.LOAD)
  def LBU     = BitPat("????????????" + Funct3.LBU + "?????" + Opcodes.LOAD)
  def LHU     = BitPat("????????????" + Funct3.LHU + "?????" + Opcodes.LOAD)
  def SB      = BitPat("???????" + "?????" + "?????" + Funct3.SB + "?????" + Opcodes.STORE)
  def SH      = BitPat("???????" + "?????" + "?????" + Funct3.SH + "?????" + Opcodes.STORE)
  def SW      = BitPat("???????" + "?????" + "?????" + Funct3.SW + "?????" + Opcodes.STORE)
  def ADDI    = BitPat("????????????" + Funct3.ADDI+ "?????" + Opcodes.OP_IMM)
  def SLTI    = BitPat("????????????" + Funct3.SLTI+ "?????" + Opcodes.OP_IMM)
  def SLTIU   = BitPat("????????????" + Funct3.SLTIU+"?????" + Opcodes.OP_IMM)
  def XORI    = BitPat("????????????" + Funct3.XORI+ "?????" + Opcodes.OP_IMM)
  def ORI     = BitPat("????????????" + Funct3.ORI + "?????" + Opcodes.OP_IMM)
  def ANDI    = BitPat("????????????" + Funct3.ANDI+ "?????" + Opcodes.OP_IMM)
  def SLLI    = BitPat(Funct7.SLLI + "???????" + Funct3.SLLI + "?????" + Opcodes.OP_IMM)
  def SRLI    = BitPat(Funct7.SRLI + "???????" + Funct3.SRLI + "?????" + Opcodes.OP_IMM)
  def SRAI    = BitPat(Funct7.SRAI + "???????" + Funct3.SRAI + "?????" + Opcodes.OP_IMM)
  def ADD     = BitPat(Funct7.ADD  + "?????" + "?????" + Funct3.ADD  + "?????" + Opcodes.OP)
  def SUB     = BitPat(Funct7.SUB  + "?????" + "?????" + Funct3.SUB  + "?????" + Opcodes.OP)
  def SLL     = BitPat(Funct7.SLL  + "?????" + "?????" + Funct3.SLL  + "?????" + Opcodes.OP)
  def SLT     = BitPat(Funct7.SLT  + "?????" + "?????" + Funct3.SLT  + "?????" + Opcodes.OP)
  def SLTU    = BitPat(Funct7.SLTU + "?????" + "?????" + Funct3.SLTU + "?????" + Opcodes.OP)
  def XOR     = BitPat(Funct7.XOR  + "?????" + "?????" + Funct3.XOR  + "?????" + Opcodes.OP)
  def SRL     = BitPat(Funct7.SRL  + "?????" + "?????" + Funct3.SRL  + "?????" + Opcodes.OP)
  def SRA     = BitPat(Funct7.SRA  + "?????" + "?????" + Funct3.SRA  + "?????" + Opcodes.OP)
  def OR      = BitPat(Funct7.OR   + "?????" + "?????" + Funct3.OR   + "?????" + Opcodes.OP)
  def AND     = BitPat(Funct7.AND  + "?????" + "?????" + Funct3.AND  + "?????" + Opcodes.OP)
  def CSRRW   = BitPat("????????????" + Funct3.CSRRW + "?????" + Opcodes.SYSTEM)
  def CSRRS   = BitPat("????????????" + Funct3.CSRRS + "?????" + Opcodes.SYSTEM)
  def CSRRC   = BitPat("????????????" + Funct3.CSRRC + "?????" + Opcodes.SYSTEM)
  def CSRRWI  = BitPat("????????????" + Funct3.CSRRWI+ "?????" + Opcodes.SYSTEM)
  def CSRRSI  = BitPat("????????????" + Funct3.CSRRSI+ "?????" + Opcodes.SYSTEM)
  def CSRRCI  = BitPat("????????????" + Funct3.CSRRCI+ "?????" + Opcodes.SYSTEM)
  def ECALL   = BitPat(Funct12.ECALL + "00000" + Funct3.ECALL + "00000" + Opcodes.SYSTEM)
  def EBREAK  = BitPat(Funct12.EBREAK+ "00000" + Funct3.EBREAK+ "00000" + Opcodes.SYSTEM)
  def MRET    = BitPat(Funct12.MRET  + "00000" + Funct3.MRET + "00000" + Opcodes.SYSTEM)
}

trait Constants extends ISA {
  implicit val config: CPUConfig

  val XLEN: Int = config.XLEN
  val NR_REGS = config.NR_REGS
  val PC_START = "h80000000".U(XLEN.W)

  object CoreType extends ChiselEnum {
    val SingleCycle, Pipeline = Value
  }

  object PCSel extends ChiselEnum {
    val PC_4, PC_BR, PC_JMP, PC_JALR, PC_TRAP, PC_MRET = Value
  }

  object OpASel extends ChiselEnum {
    val RS1, PC, X = Value
  }

  object OpBSel extends ChiselEnum {
    val RS2, IMM, X = Value
  }

  object AluOp extends ChiselEnum {
    val ADD, SUB, AND, OR, XOR, SLL, SRL, SRA, SLT, SLTU, COPY_B, X = Value
  }

  object WBSel extends ChiselEnum {
    val ALU, MEM, PC4, CSR, X = Value
  }

  object MemType extends ChiselEnum {
    val X, B, H, W, BU, HU = Value
  }

  object CSROp extends ChiselEnum {
    val X, W, S, C = Value
  }

  val MSTATUS_ADDR = "h300".U(12.W)
  val MTVEC_ADDR   = "h305".U(12.W)
  val MEPC_ADDR    = "h341".U(12.W)
  val MCAUSE_ADDR  = "h342".U(12.W)

  val ILLEGAL_INST_CAUSE = 2.U(XLEN.W)
  val ECALL_M_CAUSE      = 11.U(XLEN.W)
}
